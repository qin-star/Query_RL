# DeepRetrieval Ã— LangChain-Chatchat å¿«é€Ÿå®æ–½æŒ‡å—

> 5æ­¥å¿«é€Ÿé›†æˆ,1å¤©å†…å®Œæˆä¸Šçº¿!

---

## ğŸ¯ å®æ–½ç›®æ ‡

å°†DeepRetrievalçš„æŸ¥è¯¢é‡å†™èƒ½åŠ›é›†æˆåˆ°LangChain-Chatchat,æå‡RAGæ£€ç´¢å‡†ç¡®ç‡ã€‚

**é¢„æœŸæ•ˆæœ**:
- âœ… æ£€ç´¢å‡†ç¡®ç‡æå‡ 20-30%
- âœ… ç”¨æˆ·æŸ¥è¯¢ä½“éªŒä¼˜åŒ–
- âœ… ç³»ç»Ÿç¨³å®šæ€§ä¿æŒ99.5%+

---

## ğŸ“‹ å‰ç½®æ£€æŸ¥æ¸…å•

åœ¨å¼€å§‹å‰,è¯·ç¡®è®¤:

- [ ] LangChain-Chatchatå·²æˆåŠŸå¯åŠ¨å¹¶èƒ½æ­£å¸¸å¯¹è¯
- [ ] DeepRetrievalæ¨¡å‹å·²è®­ç»ƒå®Œæˆ
- [ ] æœ‰GPUèµ„æºå¯ä»¥è¿è¡ŒvLLMæœåŠ¡
- [ ] Pythonç¯å¢ƒå·²é…ç½®(Python 3.8+)
- [ ] å¯¹LangChain-Chatchatæœ‰åŸºæœ¬äº†è§£

**éªŒè¯å‘½ä»¤**:
```bash
# 1. æ£€æŸ¥LangChain-Chatchat
curl http://localhost:7861/docs

# 2. æ£€æŸ¥Pythonç‰ˆæœ¬
python --version  # åº”æ˜¾ç¤º 3.8+

# 3. æ£€æŸ¥GPU
nvidia-smi
```

---

## ğŸš€ ç¬¬ä¸€æ­¥: å¯åŠ¨DeepRetrievalæœåŠ¡ (30åˆ†é’Ÿ)

### 1.1 å‡†å¤‡è®­ç»ƒå¥½çš„æ¨¡å‹

```bash
cd DeepRetrieval-main/code

# å‡è®¾ä½ å·²ç»å®Œæˆè®­ç»ƒ,æ¨¡å‹ä¿å­˜åœ¨:
# output/wuboshi_rlhf/checkpoint-final/
```

### 1.2 å¯åŠ¨vLLMæœåŠ¡

```bash
# æ–¹æ³•1: ç›´æ¥å¯åŠ¨(æ¨è)
vllm serve output/wuboshi_rlhf/checkpoint-final \
    --host 0.0.0.0 \
    --port 8001 \
    --gpu-memory-utilization 0.7 \
    --max-model-len 2048 \
    --trust-remote-code

# æ–¹æ³•2: ä½¿ç”¨screenåå°è¿è¡Œ
screen -S deepretrieval-vllm
vllm serve output/wuboshi_rlhf/checkpoint-final \
    --host 0.0.0.0 \
    --port 8001 \
    --gpu-memory-utilization 0.7
# Ctrl+A+D é€€å‡ºscreen

# æŸ¥çœ‹æ—¥å¿—
screen -r deepretrieval-vllm
```

### 1.3 éªŒè¯æœåŠ¡

```bash
# æµ‹è¯•API
curl http://localhost:8001/v1/models

# åº”è¿”å›ç±»ä¼¼:
# {
#   "object": "list",
#   "data": [{"id": "...", "object": "model", ...}]
# }
```

```python
# æµ‹è¯•æŸ¥è¯¢é‡å†™
from openai import OpenAI

client = OpenAI(
    api_key="EMPTY",
    base_url="http://localhost:8001/v1"
)

response = client.chat.completions.create(
    model="query-rewrite",  # æˆ–ä½ çš„æ¨¡å‹ID
    messages=[{
        "role": "user",
        "content": "èƒ¶åŸè›‹ç™½æ€ä¹ˆåƒ?"
    }],
    max_tokens=256
)

print(response.choices[0].message.content)
```

âœ… **æ£€æŸ¥ç‚¹**: èƒ½å¤ŸæˆåŠŸè°ƒç”¨APIå¹¶è·å¾—é‡å†™ç»“æœ

---

## ğŸ”§ ç¬¬äºŒæ­¥: åˆ›å»ºæŸ¥è¯¢é‡å†™ä¸­é—´ä»¶ (20åˆ†é’Ÿ)

### 2.1 åˆ›å»ºç›®å½•ç»“æ„

```bash
cd Langchain-Chatchat-master/libs/chatchat-server/chatchat/server

# åˆ›å»ºmiddlewareç›®å½•
mkdir -p middleware
touch middleware/__init__.py
```

### 2.2 åˆ›å»ºquery_rewriter.py

å°†ä»¥ä¸‹å®Œæ•´ä»£ç ä¿å­˜åˆ° `middleware/query_rewriter.py`:

```python
"""
æŸ¥è¯¢é‡å†™ä¸­é—´ä»¶ - DeepRetrievalé›†æˆ
"""

from typing import Optional, Callable
import logging
from functools import wraps
import time
import re
import json

from openai import OpenAI

logger = logging.getLogger(__name__)


class QueryRewriterMiddleware:
    """æŸ¥è¯¢é‡å†™ä¸­é—´ä»¶"""
    
    def __init__(
        self,
        api_url: str = "http://localhost:8001/v1",
        enable: bool = True,
        timeout: float = 2.0,
        fallback_enabled: bool = True
    ):
        self.enable = enable
        self.timeout = timeout
        self.fallback_enabled = fallback_enabled
        
        if self.enable:
            self.client = OpenAI(
                api_key="EMPTY",
                base_url=api_url,
                timeout=timeout
            )
            logger.info(f"âœ“ QueryRewriterMiddlewareåˆå§‹åŒ–æˆåŠŸ - API: {api_url}")
        else:
            logger.info("QueryRewriterMiddlewareæœªå¯ç”¨")
    
    def rewrite(self, query: str, context: str = "") -> dict:
        """
        é‡å†™æŸ¥è¯¢
        
        Returns:
            {
                "original": åŸå§‹æŸ¥è¯¢,
                "rewritten": é‡å†™åæŸ¥è¯¢,
                "method": "model" | "rule" | "none",
                "success": bool,
                "latency_ms": float
            }
        """
        if not self.enable:
            return {
                "original": query,
                "rewritten": query,
                "method": "none",
                "success": True,
                "latency_ms": 0
            }
        
        start_time = time.time()
        
        try:
            # è°ƒç”¨DeepRetrievalæ¨¡å‹
            response = self.client.chat.completions.create(
                model="query-rewrite",  # æ ¹æ®å®é™…æ¨¡å‹IDè°ƒæ•´
                messages=[{
                    "role": "user",
                    "content": self._build_prompt(query, context)
                }],
                max_tokens=512,
                temperature=0.3
            )
            
            content = response.choices[0].message.content
            rewritten = self._parse_response(content, query)
            
            latency = (time.time() - start_time) * 1000
            
            return {
                "original": query,
                "rewritten": rewritten,
                "method": "model",
                "success": True,
                "latency_ms": latency
            }
            
        except Exception as e:
            logger.warning(f"æŸ¥è¯¢é‡å†™å¤±è´¥: {e}")
            
            # é™çº§ç­–ç•¥
            if self.fallback_enabled:
                rewritten = self._rule_based_rewrite(query)
                method = "rule" if rewritten != query else "none"
            else:
                rewritten = query
                method = "none"
            
            latency = (time.time() - start_time) * 1000
            
            return {
                "original": query,
                "rewritten": rewritten,
                "method": method,
                "success": False,
                "latency_ms": latency
            }
    
    def _build_prompt(self, query: str, context: str) -> str:
        """æ„å»ºæç¤ºè¯"""
        prompt = f"""ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä¿å¥å“çŸ¥è¯†åº“æŸ¥è¯¢ä¼˜åŒ–åŠ©æ‰‹ã€‚

è¯·ä¼˜åŒ–ä»¥ä¸‹æŸ¥è¯¢,ä½¿å…¶æ›´é€‚åˆæ£€ç´¢:

åŸå§‹æŸ¥è¯¢: {query}
"""
        if context:
            prompt += f"å¯¹è¯ä¸Šä¸‹æ–‡: {context}\n"
        
        prompt += """
è¾“å‡ºæ ¼å¼:
<think>åˆ†ææŸ¥è¯¢æ„å›¾...</think>
<answer>{"query": "ä¼˜åŒ–åçš„æŸ¥è¯¢"}</answer>
"""
        return prompt
    
    def _parse_response(self, content: str, fallback: str) -> str:
        """è§£æå“åº”"""
        try:
            # å°è¯•è§£æJSONæ ¼å¼
            match = re.search(r'<answer>(.*?)</answer>', content, re.DOTALL)
            if match:
                result = json.loads(match.group(1).strip())
                return result.get("query", fallback)
            
            # å°è¯•ç›´æ¥æå–æ–‡æœ¬
            if "ä¼˜åŒ–å" in content or "æ”¹å†™" in content:
                lines = content.split('\n')
                for line in lines:
                    if line.strip() and not line.startswith('<'):
                        return line.strip()
        except:
            pass
        
        return fallback
    
    def _rule_based_rewrite(self, query: str) -> str:
        """
        åŸºäºè§„åˆ™çš„æŸ¥è¯¢é‡å†™(é™çº§æ–¹æ¡ˆ)
        
        æ ¹æ®ä½ çš„æ•°æ®é›†ç‰¹ç‚¹å®šåˆ¶è§„åˆ™
        """
        # è§„åˆ™1: äº§å“ä½¿ç”¨æ–¹æ³•
        if any(word in query for word in ["æ€ä¹ˆç”¨", "æ€ä¹ˆåƒ", "å¦‚ä½•æœç”¨", "æ€ä¹ˆå–"]):
            # æå–äº§å“å
            if "èƒ¶åŸè›‹ç™½" in query:
                return "èƒ¶åŸè›‹ç™½è‚½ ä½¿ç”¨æ–¹æ³• æ¨èç”¨é‡ é€‚ç”¨äººç¾¤"
            elif "è™¾é’ç´ " in query:
                return "è™¾é’ç´  æœç”¨æ–¹æ³• ç”¨é‡ æ—¶é—´"
            elif "ç›Šç”ŸèŒ" in query:
                return "ç›Šç”ŸèŒ æœç”¨æ–¹æ³• æœ€ä½³æ—¶é—´"
            else:
                return f"{query} ä½¿ç”¨æ–¹æ³• ç”¨é‡"
        
        # è§„åˆ™2: å­•æœŸ/å“ºä¹³æœŸç¦å¿Œ
        if any(word in query for word in ["å­•å¦‡", "å¤‡å­•", "å“ºä¹³", "æ€€å­•"]):
            return f"{query} ç¦å¿Œ æ³¨æ„äº‹é¡¹ å®‰å…¨æ€§"
        
        # è§„åˆ™3: æ•ˆæœå’¨è¯¢
        if any(word in query for word in ["æ•ˆæœ", "æœ‰ç”¨å—", "èƒ½ä¸èƒ½", "å¯ä»¥å—"]):
            return f"{query} åŠŸæ•ˆ ä½œç”¨ é€‚ç”¨"
        
        # è§„åˆ™4: äº§å“å¯¹æ¯”
        if "å’Œ" in query and "åŒºåˆ«" in query:
            return f"{query} æˆåˆ†å¯¹æ¯” åŠŸæ•ˆåŒºåˆ«"
        
        # è§„åˆ™5: è¡¥å……å…³é”®è¯
        if len(query) < 5:
            return f"{query} äº§å“ ä»‹ç»"
        
        return query


# ========== å…¨å±€å•ä¾‹ ==========

_query_rewriter = None


def get_query_rewriter() -> QueryRewriterMiddleware:
    """è·å–å…¨å±€Queryé‡å†™å™¨(å•ä¾‹)"""
    global _query_rewriter
    
    if _query_rewriter is None:
        try:
            from chatchat.settings import Settings
            config = Settings.query_rewrite_settings
            
            _query_rewriter = QueryRewriterMiddleware(
                api_url=config.api_url,
                enable=config.enable,
                timeout=config.timeout,
                fallback_enabled=config.fallback_enabled
            )
        except Exception as e:
            logger.warning(f"æ— æ³•ä»é…ç½®åŠ è½½,ä½¿ç”¨é»˜è®¤é…ç½®: {e}")
            _query_rewriter = QueryRewriterMiddleware(
                api_url="http://localhost:8001/v1",
                enable=False,  # é»˜è®¤å…³é—­
                timeout=2.0,
                fallback_enabled=True
            )
    
    return _query_rewriter


# ========== è£…é¥°å™¨ ==========

def with_query_rewrite(func: Callable):
    """
    è£…é¥°å™¨: è‡ªåŠ¨ä¸ºå‡½æ•°æ·»åŠ æŸ¥è¯¢é‡å†™
    
    ç¤ºä¾‹:
        @with_query_rewrite
        async def search_docs(query, ...):
            ...
    """
    @wraps(func)
    async def async_wrapper(*args, **kwargs):
        query = kwargs.get('query', None)
        
        if query:
            rewriter = get_query_rewriter()
            result = rewriter.rewrite(query)
            
            logger.info(
                f"ğŸ”„ Queryé‡å†™ [{result['method']}] "
                f"({result['latency_ms']:.0f}ms): "
                f"'{result['original']}' -> '{result['rewritten']}'"
            )
            
            kwargs['query'] = result['rewritten']
        
        return await func(*args, **kwargs)
    
    @wraps(func)
    def sync_wrapper(*args, **kwargs):
        query = kwargs.get('query', None)
        
        if query:
            rewriter = get_query_rewriter()
            result = rewriter.rewrite(query)
            
            logger.info(
                f"ğŸ”„ Queryé‡å†™ [{result['method']}] "
                f"({result['latency_ms']:.0f}ms): "
                f"'{result['original']}' -> '{result['rewritten']}'"
            )
            
            kwargs['query'] = result['rewritten']
        
        return func(*args, **kwargs)
    
    # åˆ¤æ–­æ˜¯å¦æ˜¯å¼‚æ­¥å‡½æ•°
    import asyncio
    if asyncio.iscoroutinefunction(func):
        return async_wrapper
    else:
        return sync_wrapper
```

âœ… **æ£€æŸ¥ç‚¹**: query_rewriter.pyæ–‡ä»¶åˆ›å»ºæˆåŠŸ

---

## âš™ï¸ ç¬¬ä¸‰æ­¥: é…ç½®é›†æˆ (15åˆ†é’Ÿ)

### 3.1 åˆ›å»ºé…ç½®æ–‡ä»¶

```bash
cd Langchain-Chatchat-master/libs/chatchat-server
mkdir -p data
```

åˆ›å»º `data/query_rewrite_settings.yaml`:

```yaml
# DeepRetrievalæŸ¥è¯¢é‡å†™é…ç½®
query_rewrite_settings:
  # æ ¸å¿ƒå¼€å…³
  enable: true  # æ˜¯å¦å¯ç”¨æŸ¥è¯¢é‡å†™
  
  # APIé…ç½®
  api_url: "http://localhost:8001/v1"  # vLLMæœåŠ¡åœ°å€
  timeout: 2.0  # è¶…æ—¶æ—¶é—´(ç§’)
  
  # é™çº§ç­–ç•¥
  fallback_enabled: true  # å¯ç”¨è§„åˆ™é™çº§
  
  # A/Bæµ‹è¯•(å¯é€‰)
  ab_test:
    enabled: false  # æš‚ä¸å¯ç”¨
    group_ratio: 0.5
  
  # ç¼“å­˜(å¯é€‰)
  cache:
    enabled: false  # æš‚ä¸å¯ç”¨
    max_size: 1000
    ttl: 3600
```

### 3.2 ä¿®æ”¹settings.py

åœ¨ `chatchat/settings.py` æ–‡ä»¶æœ«å°¾æ·»åŠ :

```python
# ========== åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ  ==========

class QueryRewriteSettings(BaseFileSettings):
    """DeepRetrievalæŸ¥è¯¢é‡å†™é…ç½®"""
    
    model_config = SettingsConfigDict(
        yaml_file=CHATCHAT_ROOT / "data/query_rewrite_settings.yaml"
    )
    
    enable: bool = False
    api_url: str = "http://localhost:8001/v1"
    timeout: float = 2.0
    fallback_enabled: bool = True
    ab_test: Dict = {"enabled": False, "group_ratio": 0.5}
    cache: Dict = {"enabled": False, "max_size": 1000, "ttl": 3600}


# åœ¨Settingsç±»ä¸­æ·»åŠ (æ‰¾åˆ°class Settings:)
class Settings:
    # ... ç°æœ‰ä»£ç  ...
    
    # æ·»åŠ è¿™ä¸€è¡Œ
    query_rewrite_settings: QueryRewriteSettings = QueryRewriteSettings()
```

âœ… **æ£€æŸ¥ç‚¹**: é…ç½®æ–‡ä»¶å’ŒSettingsç±»ä¿®æ”¹å®Œæˆ

---

## ğŸ”Œ ç¬¬å››æ­¥: é›†æˆåˆ°å¯¹è¯æµç¨‹ (10åˆ†é’Ÿ)

### 4.1 ä¿®æ”¹kb_chat.py

ç¼–è¾‘ `chatchat/server/chat/kb_chat.py`:

**æ­¥éª¤1**: åœ¨æ–‡ä»¶é¡¶éƒ¨æ·»åŠ å¯¼å…¥(æ‰¾åˆ°å…¶ä»–importè¯­å¥é™„è¿‘):

```python
# åœ¨æ–‡ä»¶é¡¶éƒ¨å¯¼å…¥åŒºåŸŸæ·»åŠ 
from chatchat.server.middleware.query_rewriter import get_query_rewriter
```

**æ­¥éª¤2**: åœ¨`kb_chat`å‡½æ•°ä¸­æ·»åŠ æŸ¥è¯¢é‡å†™é€»è¾‘:

æ‰¾åˆ°è¿™ä¸ªå‡½æ•°:
```python
async def kb_chat(query: str = Body(...), ...):
    # ...
    async def knowledge_base_chat_iterator() -> AsyncIterable[str]:
        try:
            nonlocal history, prompt_name, max_tokens
            
            # ===== åœ¨è¿™é‡Œæ·»åŠ æŸ¥è¯¢é‡å†™ =====
            # è·å–é‡å†™å™¨
            rewriter = get_query_rewriter()
            rewrite_result = rewriter.rewrite(query)
            
            # ä¿å­˜åŸå§‹query
            original_query = query
            optimized_query = rewrite_result['rewritten']
            
            # è®°å½•æ—¥å¿—
            logger.info(
                f"ğŸ”„ [Queryé‡å†™] æ–¹æ³•={rewrite_result['method']}, "
                f"è€—æ—¶={rewrite_result['latency_ms']:.0f}ms\n"
                f"   åŸå§‹: {original_query}\n"
                f"   é‡å†™: {optimized_query}"
            )
            # ===== æŸ¥è¯¢é‡å†™ç»“æŸ =====
            
            history = [History.from_data(h) for h in history]
            
            if mode == "local_kb":
                kb = KBServiceFactory.get_service_by_name(kb_name)
                ok, msg = kb.check_embed_model()
                if not ok:
                    raise ValueError(msg)
                
                # ä½¿ç”¨é‡å†™åçš„queryæ£€ç´¢(é‡è¦!)
                docs = await run_in_threadpool(search_docs,
                                                query=optimized_query,  # æ”¹è¿™é‡Œ!
                                                knowledge_base_name=kb_name,
                                                top_k=top_k,
                                                score_threshold=score_threshold,
                                                file_name="",
                                                metadata={})
                # ... åç»­ä»£ç ä¿æŒä¸å˜ ...
```

**å®Œæ•´ä¿®æ”¹ç¤ºä¾‹**:

```python
async def kb_chat(query: str = Body(..., description="ç”¨æˆ·è¾“å…¥", examples=["ä½ å¥½"]),
                mode: Literal["local_kb", "temp_kb", "search_engine"] = Body("local_kb"),
                # ... å…¶ä»–å‚æ•° ...
                ):
    if mode == "local_kb":
        kb = KBServiceFactory.get_service_by_name(kb_name)
        if kb is None:
            return BaseResponse(code=404, msg=f"æœªæ‰¾åˆ°çŸ¥è¯†åº“ {kb_name}")
    
    async def knowledge_base_chat_iterator() -> AsyncIterable[str]:
        try:
            nonlocal history, prompt_name, max_tokens
            
            # ========== DeepRetrievalæŸ¥è¯¢é‡å†™ ==========
            rewriter = get_query_rewriter()
            rewrite_result = rewriter.rewrite(query)
            
            original_query = query
            optimized_query = rewrite_result['rewritten']
            
            logger.info(
                f"ğŸ”„ [Queryé‡å†™] {rewrite_result['method']} "
                f"({rewrite_result['latency_ms']:.0f}ms): "
                f"'{original_query}' -> '{optimized_query}'"
            )
            # ==========================================
            
            history = [History.from_data(h) for h in history]
            
            if mode == "local_kb":
                kb = KBServiceFactory.get_service_by_name(kb_name)
                ok, msg = kb.check_embed_model()
                if not ok:
                    raise ValueError(msg)
                
                # ä½¿ç”¨é‡å†™åçš„query
                docs = await run_in_threadpool(
                    search_docs,
                    query=optimized_query,  # â† ä½¿ç”¨é‡å†™åçš„query
                    knowledge_base_name=kb_name,
                    top_k=top_k,
                    score_threshold=score_threshold,
                    file_name="",
                    metadata={}
                )
                
                source_documents = format_reference(kb_name, docs, api_address(is_public=True))
            
            # ... åç»­ä»£ç å®Œå…¨ä¸å˜ ...
```

âœ… **æ£€æŸ¥ç‚¹**: kb_chat.pyä¿®æ”¹å®Œæˆ,å¯¼å…¥å’Œé‡å†™é€»è¾‘éƒ½å·²æ·»åŠ 

---

## âœ… ç¬¬äº”æ­¥: æµ‹è¯•å’Œä¸Šçº¿ (15åˆ†é’Ÿ)

### 5.1 é‡å¯LangChain-Chatchat

```bash
# å¦‚æœä½¿ç”¨screen
screen -ls  # æŸ¥çœ‹ç°æœ‰session
screen -X -S chatchat quit  # å…³é—­æ—§session

# å¯åŠ¨æ–°session
screen -S chatchat
cd Langchain-Chatchat-master/libs/chatchat-server
python -m chatchat.startup

# Ctrl+A+D é€€å‡ºscreen
```

### 5.2 æµ‹è¯•é›†æˆæ•ˆæœ

åˆ›å»ºæµ‹è¯•è„šæœ¬ `test_integration.py`:

```python
"""
é›†æˆæµ‹è¯•è„šæœ¬
"""

import requests
import json


def test_kb_chat(query: str, kb_name: str = "samples"):
    """æµ‹è¯•çŸ¥è¯†åº“å¯¹è¯"""
    
    url = "http://localhost:7861/chat/kb_chat"
    
    payload = {
        "query": query,
        "kb_name": kb_name,
        "mode": "local_kb",
        "top_k": 5,
        "score_threshold": 0.5,
        "stream": False
    }
    
    print(f"\n{'='*60}")
    print(f"ğŸ“ æµ‹è¯•Query: {query}")
    print(f"{'='*60}")
    
    response = requests.post(url, json=payload)
    
    if response.status_code == 200:
        result = response.json()
        print(f"âœ… çŠ¶æ€: æˆåŠŸ")
        print(f"ğŸ“„ å›ç­”: {result.get('answer', 'N/A')[:200]}...")
        print(f"ğŸ“š å‚è€ƒæ–‡æ¡£æ•°: {len(result.get('docs', []))}")
    else:
        print(f"âŒ çŠ¶æ€: å¤±è´¥ ({response.status_code})")
        print(f"é”™è¯¯: {response.text}")
    
    return response


if __name__ == "__main__":
    # æµ‹è¯•ç”¨ä¾‹(æ ¹æ®ä½ çš„çŸ¥è¯†åº“è°ƒæ•´)
    test_cases = [
        "èƒ¶åŸè›‹ç™½æ€ä¹ˆåƒ",
        "å­•å¦‡èƒ½å–å—",
        "æœ‰ä»€ä¹ˆæ•ˆæœ",
        "å’Œè™¾é’ç´ æœ‰ä»€ä¹ˆåŒºåˆ«"
    ]
    
    for query in test_cases:
        test_kb_chat(query, kb_name="wuboshi_faq")  # æ”¹æˆä½ çš„çŸ¥è¯†åº“å
    
    print(f"\n{'='*60}")
    print("âœ… æ‰€æœ‰æµ‹è¯•å®Œæˆ!")
    print("è¯·æ£€æŸ¥LangChain-Chatchatæ—¥å¿—,æŸ¥çœ‹'ğŸ”„ Queryé‡å†™'å­—æ ·")
    print(f"{'='*60}")
```

è¿è¡Œæµ‹è¯•:

```bash
python test_integration.py
```

### 5.3 æŸ¥çœ‹æ—¥å¿—ç¡®è®¤

```bash
# æŸ¥çœ‹LangChain-Chatchatæ—¥å¿—
tail -f Langchain-Chatchat-master/libs/chatchat-server/data/logs/*.log

# åº”è¯¥èƒ½çœ‹åˆ°ç±»ä¼¼è¾“å‡º:
# ğŸ”„ [Queryé‡å†™] model (145ms): 'èƒ¶åŸè›‹ç™½æ€ä¹ˆåƒ' -> 'èƒ¶åŸè›‹ç™½è‚½ ä½¿ç”¨æ–¹æ³• æ¨èç”¨é‡'
```

### 5.4 å¯¹æ¯”æµ‹è¯•

```python
# åˆ›å»º compare_results.py
import requests


def compare_with_without_rewrite(query: str):
    """å¯¹æ¯”æœ‰æ— æŸ¥è¯¢é‡å†™çš„æ•ˆæœ"""
    
    url = "http://localhost:7861/chat/kb_chat"
    payload = {
        "query": query,
        "kb_name": "wuboshi_faq",
        "top_k": 3,
        "stream": False
    }
    
    # æµ‹è¯•1: å¯ç”¨æŸ¥è¯¢é‡å†™
    # (åœ¨é…ç½®ä¸­enable: true)
    response1 = requests.post(url, json=payload)
    result1 = response1.json()
    
    print(f"Query: {query}")
    print(f"\nå¯ç”¨æŸ¥è¯¢é‡å†™:")
    print(f"  å›ç­”: {result1.get('answer', '')[:150]}...")
    print(f"  ç›¸å…³åº¦: {[doc.get('score', 0) for doc in result1.get('docs', [])[:3]]}")
    
    # TODO: å¯¹æ¯”æµ‹è¯•éœ€è¦æ‰‹åŠ¨å…³é—­enableåå†æµ‹è¯•


if __name__ == "__main__":
    compare_with_without_rewrite("èƒ¶åŸè›‹ç™½æ€ä¹ˆåƒ")
```

âœ… **æ£€æŸ¥ç‚¹**: æµ‹è¯•é€šè¿‡,èƒ½çœ‹åˆ°æŸ¥è¯¢é‡å†™æ—¥å¿—

---

## ğŸ“Š éªŒæ”¶æ ‡å‡†

### å¿…é¡»é€šè¿‡çš„æ£€æŸ¥é¡¹

- [ ] DeepRetrieval vLLMæœåŠ¡æ­£å¸¸è¿è¡Œ
- [ ] LangChain-ChatchatæœåŠ¡æ­£å¸¸è¿è¡Œ
- [ ] æµ‹è¯•æŸ¥è¯¢èƒ½æˆåŠŸè¿”å›ç»“æœ
- [ ] æ—¥å¿—ä¸­èƒ½çœ‹åˆ°"ğŸ”„ Queryé‡å†™"å­—æ ·
- [ ] æŸ¥è¯¢é‡å†™latency < 500ms
- [ ] ç³»ç»Ÿæ•´ä½“å“åº”æ­£å¸¸

### æ•ˆæœè¯„ä¼°æŒ‡æ ‡

è¿è¡Œä¸€å‘¨å,æ”¶é›†ä»¥ä¸‹æ•°æ®:

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… | è¾¾æˆ |
|------|------|------|------|
| æŸ¥è¯¢é‡å†™æˆåŠŸç‡ | > 95% | ___ % | â˜ |
| å¹³å‡é‡å†™å»¶è¿Ÿ | < 300ms | ___ ms | â˜ |
| ç”¨æˆ·æ»¡æ„åº¦æå‡ | > 10% | ___ % | â˜ |
| ç³»ç»Ÿå¯ç”¨æ€§ | > 99% | ___ % | â˜ |

---

## ğŸ”§ å¸¸è§é—®é¢˜æ’æŸ¥

### é—®é¢˜1: æ—¥å¿—ä¸­æ²¡æœ‰çœ‹åˆ°æŸ¥è¯¢é‡å†™

**ç—‡çŠ¶**: æµ‹è¯•æ—¶æ²¡æœ‰"ğŸ”„ Queryé‡å†™"æ—¥å¿—

**æ’æŸ¥æ­¥éª¤**:
```bash
# 1. æ£€æŸ¥é…ç½®
cat data/query_rewrite_settings.yaml
# ç¡®è®¤ enable: true

# 2. æ£€æŸ¥å¯¼å…¥
cd chatchat/server/chat
grep "query_rewriter" kb_chat.py
# åº”è¯¥æœ‰importè¯­å¥

# 3. æ£€æŸ¥æ—¥å¿—çº§åˆ«
# åœ¨startup.pyä¸­è®¾ç½®
import logging
logging.basicConfig(level=logging.INFO)
```

### é—®é¢˜2: æŸ¥è¯¢é‡å†™å¤±è´¥,ä½¿ç”¨ruleé™çº§

**ç—‡çŠ¶**: æ—¥å¿—æ˜¾ç¤º `[Queryé‡å†™] rule`

**åŸå› **: vLLMæœåŠ¡ä¸å¯è¾¾æˆ–è¶…æ—¶

**æ’æŸ¥æ­¥éª¤**:
```bash
# 1. æ£€æŸ¥vLLMæœåŠ¡
curl http://localhost:8001/v1/models

# 2. æ£€æŸ¥ç«¯å£
netstat -tlnp | grep 8001

# 3. æ£€æŸ¥é˜²ç«å¢™
# Windows
netsh advfirewall firewall show rule name=all | findstr 8001

# 4. æµ‹è¯•è¿æ¥
python -c "
from openai import OpenAI
client = OpenAI(api_key='EMPTY', base_url='http://localhost:8001/v1')
print(client.models.list())
"
```

### é—®é¢˜3: æŸ¥è¯¢é‡å†™å¾ˆæ…¢(>1s)

**ç—‡çŠ¶**: latency_ms > 1000

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```yaml
# è°ƒæ•´é…ç½®
query_rewrite_settings:
  timeout: 1.0  # é™ä½è¶…æ—¶æ—¶é—´,å¿«é€Ÿé™çº§
  
  cache:
    enabled: true  # å¯ç”¨ç¼“å­˜
    max_size: 5000
```

```python
# åœ¨query_rewriter.pyä¸­æ·»åŠ ç¼“å­˜
from functools import lru_cache

class QueryRewriterMiddleware:
    def __init__(self, ...):
        # ...
        self.cache = {}
    
    def rewrite(self, query, context=""):
        # æ£€æŸ¥ç¼“å­˜
        cache_key = f"{query}:{context}"
        if cache_key in self.cache:
            result = self.cache[cache_key]
            result['latency_ms'] = 0  # ç¼“å­˜å‘½ä¸­
            return result
        
        # åŸæœ‰é€»è¾‘...
        result = self._do_rewrite(query, context)
        
        # å­˜å…¥ç¼“å­˜
        if len(self.cache) < 1000:
            self.cache[cache_key] = result
        
        return result
```

### é—®é¢˜4: ImportErroræˆ–ModuleNotFoundError

**ç—‡çŠ¶**: `ImportError: cannot import name 'get_query_rewriter'`

**è§£å†³æ–¹æ¡ˆ**:
```bash
# 1. æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
ls chatchat/server/middleware/query_rewriter.py

# 2. æ£€æŸ¥__init__.py
cat chatchat/server/middleware/__init__.py

# 3. é‡å¯Pythonç¯å¢ƒ
# å¦‚æœä½¿ç”¨conda/venv,é‡æ–°æ¿€æ´»

# 4. æ£€æŸ¥Pythonè·¯å¾„
python -c "import sys; print(sys.path)"
```

---

## ğŸ¯ ä¸‹ä¸€æ­¥ä¼˜åŒ–å»ºè®®

é›†æˆæˆåŠŸå,å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–:

### Week 2: æ€§èƒ½ä¼˜åŒ–
- [ ] å¯ç”¨ç¼“å­˜æœºåˆ¶
- [ ] æ‰¹é‡æŸ¥è¯¢é‡å†™
- [ ] å¼‚æ­¥å¤„ç†ä¼˜åŒ–

### Week 3: æ•ˆæœä¼˜åŒ–
- [ ] æ”¶é›†badcase
- [ ] ä¼˜åŒ–è§„åˆ™åº“
- [ ] è°ƒæ•´æ¨¡å‹prompt

### Week 4: æ··åˆæ£€ç´¢
- [ ] å®ç°RRFèåˆ
- [ ] æ·»åŠ é‡æ’åº
- [ ] A/Bæµ‹è¯•å¯¹æ¯”

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [ç»†åŒ–é›†æˆæ–¹æ¡ˆå…¨æ–‡](./DeepRetrieval_LangChain_ç»†åŒ–é›†æˆæ–¹æ¡ˆ.md)
- [æ–¹æ¡ˆå¯¹æ¯”è¯´æ˜](./æ–¹æ¡ˆå¯¹æ¯”ä¸æ”¹è¿›è¯´æ˜.md)
- [DeepRetrievalè®­ç»ƒæŒ‡å—](./QUICKSTART_zh.md)
- [LangChain-Chatchatå®˜æ–¹æ–‡æ¡£](https://github.com/chatchat-space/Langchain-Chatchat)

---

## âœ… å®Œæˆç¡®è®¤

æ­å–œ!å¦‚æœä½ å®Œæˆäº†æ‰€æœ‰5ä¸ªæ­¥éª¤,ç°åœ¨ä½ å·²ç»:

- âœ… æˆåŠŸå°†DeepRetrievalé›†æˆåˆ°LangChain-Chatchat
- âœ… å®ç°äº†æŸ¥è¯¢é‡å†™èƒ½åŠ›
- âœ… å…·å¤‡å®Œæ•´çš„é™çº§æœºåˆ¶
- âœ… ç³»ç»Ÿç¨³å®šè¿è¡Œ

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**:
1. æ”¶é›†ä¸€å‘¨çš„ä½¿ç”¨æ•°æ®
2. åˆ†ææŸ¥è¯¢é‡å†™æ•ˆæœ
3. æ ¹æ®badcaseä¼˜åŒ–è§„åˆ™
4. è€ƒè™‘å®æ–½æ··åˆæ£€ç´¢ç­–ç•¥

æœ‰ä»»ä½•é—®é¢˜,è¯·æŸ¥çœ‹"å¸¸è§é—®é¢˜æ’æŸ¥"éƒ¨åˆ†æˆ–æŸ¥é˜…è¯¦ç»†æ–‡æ¡£!

ğŸ‰ **Happy Coding!**

