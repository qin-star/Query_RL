# DeepRetrieval × LangChain-Chatchat 快速实施指南

> 5步快速集成,1天内完成上线!

---

## 🎯 实施目标

将DeepRetrieval的查询重写能力集成到LangChain-Chatchat,提升RAG检索准确率。

**预期效果**:
- ✅ 检索准确率提升 20-30%
- ✅ 用户查询体验优化
- ✅ 系统稳定性保持99.5%+

---

## 📋 前置检查清单

在开始前,请确认:

- [ ] LangChain-Chatchat已成功启动并能正常对话
- [ ] DeepRetrieval模型已训练完成
- [ ] 有GPU资源可以运行vLLM服务
- [ ] Python环境已配置(Python 3.8+)
- [ ] 对LangChain-Chatchat有基本了解

**验证命令**:
```bash
# 1. 检查LangChain-Chatchat
curl http://localhost:7861/docs

# 2. 检查Python版本
python --version  # 应显示 3.8+

# 3. 检查GPU
nvidia-smi
```

---

## 🚀 第一步: 启动DeepRetrieval服务 (30分钟)

### 1.1 准备训练好的模型

```bash
cd DeepRetrieval-main/code

# 假设你已经完成训练,模型保存在:
# output/wuboshi_rlhf/checkpoint-final/
```

### 1.2 启动vLLM服务

```bash
# 方法1: 直接启动(推荐)
vllm serve output/wuboshi_rlhf/checkpoint-final \
    --host 0.0.0.0 \
    --port 8001 \
    --gpu-memory-utilization 0.7 \
    --max-model-len 2048 \
    --trust-remote-code

# 方法2: 使用screen后台运行
screen -S deepretrieval-vllm
vllm serve output/wuboshi_rlhf/checkpoint-final \
    --host 0.0.0.0 \
    --port 8001 \
    --gpu-memory-utilization 0.7
# Ctrl+A+D 退出screen

# 查看日志
screen -r deepretrieval-vllm
```

### 1.3 验证服务

```bash
# 测试API
curl http://localhost:8001/v1/models

# 应返回类似:
# {
#   "object": "list",
#   "data": [{"id": "...", "object": "model", ...}]
# }
```

```python
# 测试查询重写
from openai import OpenAI

client = OpenAI(
    api_key="EMPTY",
    base_url="http://localhost:8001/v1"
)

response = client.chat.completions.create(
    model="query-rewrite",  # 或你的模型ID
    messages=[{
        "role": "user",
        "content": "胶原蛋白怎么吃?"
    }],
    max_tokens=256
)

print(response.choices[0].message.content)
```

✅ **检查点**: 能够成功调用API并获得重写结果

---

## 🔧 第二步: 创建查询重写中间件 (20分钟)

### 2.1 创建目录结构

```bash
cd Langchain-Chatchat-master/libs/chatchat-server/chatchat/server

# 创建middleware目录
mkdir -p middleware
touch middleware/__init__.py
```

### 2.2 创建query_rewriter.py

将以下完整代码保存到 `middleware/query_rewriter.py`:

```python
"""
查询重写中间件 - DeepRetrieval集成
"""

from typing import Optional, Callable
import logging
from functools import wraps
import time
import re
import json

from openai import OpenAI

logger = logging.getLogger(__name__)


class QueryRewriterMiddleware:
    """查询重写中间件"""
    
    def __init__(
        self,
        api_url: str = "http://localhost:8001/v1",
        enable: bool = True,
        timeout: float = 2.0,
        fallback_enabled: bool = True
    ):
        self.enable = enable
        self.timeout = timeout
        self.fallback_enabled = fallback_enabled
        
        if self.enable:
            self.client = OpenAI(
                api_key="EMPTY",
                base_url=api_url,
                timeout=timeout
            )
            logger.info(f"✓ QueryRewriterMiddleware初始化成功 - API: {api_url}")
        else:
            logger.info("QueryRewriterMiddleware未启用")
    
    def rewrite(self, query: str, context: str = "") -> dict:
        """
        重写查询
        
        Returns:
            {
                "original": 原始查询,
                "rewritten": 重写后查询,
                "method": "model" | "rule" | "none",
                "success": bool,
                "latency_ms": float
            }
        """
        if not self.enable:
            return {
                "original": query,
                "rewritten": query,
                "method": "none",
                "success": True,
                "latency_ms": 0
            }
        
        start_time = time.time()
        
        try:
            # 调用DeepRetrieval模型
            response = self.client.chat.completions.create(
                model="query-rewrite",  # 根据实际模型ID调整
                messages=[{
                    "role": "user",
                    "content": self._build_prompt(query, context)
                }],
                max_tokens=512,
                temperature=0.3
            )
            
            content = response.choices[0].message.content
            rewritten = self._parse_response(content, query)
            
            latency = (time.time() - start_time) * 1000
            
            return {
                "original": query,
                "rewritten": rewritten,
                "method": "model",
                "success": True,
                "latency_ms": latency
            }
            
        except Exception as e:
            logger.warning(f"查询重写失败: {e}")
            
            # 降级策略
            if self.fallback_enabled:
                rewritten = self._rule_based_rewrite(query)
                method = "rule" if rewritten != query else "none"
            else:
                rewritten = query
                method = "none"
            
            latency = (time.time() - start_time) * 1000
            
            return {
                "original": query,
                "rewritten": rewritten,
                "method": method,
                "success": False,
                "latency_ms": latency
            }
    
    def _build_prompt(self, query: str, context: str) -> str:
        """构建提示词"""
        prompt = f"""你是一个专业的保健品知识库查询优化助手。

请优化以下查询,使其更适合检索:

原始查询: {query}
"""
        if context:
            prompt += f"对话上下文: {context}\n"
        
        prompt += """
输出格式:
<think>分析查询意图...</think>
<answer>{"query": "优化后的查询"}</answer>
"""
        return prompt
    
    def _parse_response(self, content: str, fallback: str) -> str:
        """解析响应"""
        try:
            # 尝试解析JSON格式
            match = re.search(r'<answer>(.*?)</answer>', content, re.DOTALL)
            if match:
                result = json.loads(match.group(1).strip())
                return result.get("query", fallback)
            
            # 尝试直接提取文本
            if "优化后" in content or "改写" in content:
                lines = content.split('\n')
                for line in lines:
                    if line.strip() and not line.startswith('<'):
                        return line.strip()
        except:
            pass
        
        return fallback
    
    def _rule_based_rewrite(self, query: str) -> str:
        """
        基于规则的查询重写(降级方案)
        
        根据你的数据集特点定制规则
        """
        # 规则1: 产品使用方法
        if any(word in query for word in ["怎么用", "怎么吃", "如何服用", "怎么喝"]):
            # 提取产品名
            if "胶原蛋白" in query:
                return "胶原蛋白肽 使用方法 推荐用量 适用人群"
            elif "虾青素" in query:
                return "虾青素 服用方法 用量 时间"
            elif "益生菌" in query:
                return "益生菌 服用方法 最佳时间"
            else:
                return f"{query} 使用方法 用量"
        
        # 规则2: 孕期/哺乳期禁忌
        if any(word in query for word in ["孕妇", "备孕", "哺乳", "怀孕"]):
            return f"{query} 禁忌 注意事项 安全性"
        
        # 规则3: 效果咨询
        if any(word in query for word in ["效果", "有用吗", "能不能", "可以吗"]):
            return f"{query} 功效 作用 适用"
        
        # 规则4: 产品对比
        if "和" in query and "区别" in query:
            return f"{query} 成分对比 功效区别"
        
        # 规则5: 补充关键词
        if len(query) < 5:
            return f"{query} 产品 介绍"
        
        return query


# ========== 全局单例 ==========

_query_rewriter = None


def get_query_rewriter() -> QueryRewriterMiddleware:
    """获取全局Query重写器(单例)"""
    global _query_rewriter
    
    if _query_rewriter is None:
        try:
            from chatchat.settings import Settings
            config = Settings.query_rewrite_settings
            
            _query_rewriter = QueryRewriterMiddleware(
                api_url=config.api_url,
                enable=config.enable,
                timeout=config.timeout,
                fallback_enabled=config.fallback_enabled
            )
        except Exception as e:
            logger.warning(f"无法从配置加载,使用默认配置: {e}")
            _query_rewriter = QueryRewriterMiddleware(
                api_url="http://localhost:8001/v1",
                enable=False,  # 默认关闭
                timeout=2.0,
                fallback_enabled=True
            )
    
    return _query_rewriter


# ========== 装饰器 ==========

def with_query_rewrite(func: Callable):
    """
    装饰器: 自动为函数添加查询重写
    
    示例:
        @with_query_rewrite
        async def search_docs(query, ...):
            ...
    """
    @wraps(func)
    async def async_wrapper(*args, **kwargs):
        query = kwargs.get('query', None)
        
        if query:
            rewriter = get_query_rewriter()
            result = rewriter.rewrite(query)
            
            logger.info(
                f"🔄 Query重写 [{result['method']}] "
                f"({result['latency_ms']:.0f}ms): "
                f"'{result['original']}' -> '{result['rewritten']}'"
            )
            
            kwargs['query'] = result['rewritten']
        
        return await func(*args, **kwargs)
    
    @wraps(func)
    def sync_wrapper(*args, **kwargs):
        query = kwargs.get('query', None)
        
        if query:
            rewriter = get_query_rewriter()
            result = rewriter.rewrite(query)
            
            logger.info(
                f"🔄 Query重写 [{result['method']}] "
                f"({result['latency_ms']:.0f}ms): "
                f"'{result['original']}' -> '{result['rewritten']}'"
            )
            
            kwargs['query'] = result['rewritten']
        
        return func(*args, **kwargs)
    
    # 判断是否是异步函数
    import asyncio
    if asyncio.iscoroutinefunction(func):
        return async_wrapper
    else:
        return sync_wrapper
```

✅ **检查点**: query_rewriter.py文件创建成功

---

## ⚙️ 第三步: 配置集成 (15分钟)

### 3.1 创建配置文件

```bash
cd Langchain-Chatchat-master/libs/chatchat-server
mkdir -p data
```

创建 `data/query_rewrite_settings.yaml`:

```yaml
# DeepRetrieval查询重写配置
query_rewrite_settings:
  # 核心开关
  enable: true  # 是否启用查询重写
  
  # API配置
  api_url: "http://localhost:8001/v1"  # vLLM服务地址
  timeout: 2.0  # 超时时间(秒)
  
  # 降级策略
  fallback_enabled: true  # 启用规则降级
  
  # A/B测试(可选)
  ab_test:
    enabled: false  # 暂不启用
    group_ratio: 0.5
  
  # 缓存(可选)
  cache:
    enabled: false  # 暂不启用
    max_size: 1000
    ttl: 3600
```

### 3.2 修改settings.py

在 `chatchat/settings.py` 文件末尾添加:

```python
# ========== 在文件末尾添加 ==========

class QueryRewriteSettings(BaseFileSettings):
    """DeepRetrieval查询重写配置"""
    
    model_config = SettingsConfigDict(
        yaml_file=CHATCHAT_ROOT / "data/query_rewrite_settings.yaml"
    )
    
    enable: bool = False
    api_url: str = "http://localhost:8001/v1"
    timeout: float = 2.0
    fallback_enabled: bool = True
    ab_test: Dict = {"enabled": False, "group_ratio": 0.5}
    cache: Dict = {"enabled": False, "max_size": 1000, "ttl": 3600}


# 在Settings类中添加(找到class Settings:)
class Settings:
    # ... 现有代码 ...
    
    # 添加这一行
    query_rewrite_settings: QueryRewriteSettings = QueryRewriteSettings()
```

✅ **检查点**: 配置文件和Settings类修改完成

---

## 🔌 第四步: 集成到对话流程 (10分钟)

### 4.1 修改kb_chat.py

编辑 `chatchat/server/chat/kb_chat.py`:

**步骤1**: 在文件顶部添加导入(找到其他import语句附近):

```python
# 在文件顶部导入区域添加
from chatchat.server.middleware.query_rewriter import get_query_rewriter
```

**步骤2**: 在`kb_chat`函数中添加查询重写逻辑:

找到这个函数:
```python
async def kb_chat(query: str = Body(...), ...):
    # ...
    async def knowledge_base_chat_iterator() -> AsyncIterable[str]:
        try:
            nonlocal history, prompt_name, max_tokens
            
            # ===== 在这里添加查询重写 =====
            # 获取重写器
            rewriter = get_query_rewriter()
            rewrite_result = rewriter.rewrite(query)
            
            # 保存原始query
            original_query = query
            optimized_query = rewrite_result['rewritten']
            
            # 记录日志
            logger.info(
                f"🔄 [Query重写] 方法={rewrite_result['method']}, "
                f"耗时={rewrite_result['latency_ms']:.0f}ms\n"
                f"   原始: {original_query}\n"
                f"   重写: {optimized_query}"
            )
            # ===== 查询重写结束 =====
            
            history = [History.from_data(h) for h in history]
            
            if mode == "local_kb":
                kb = KBServiceFactory.get_service_by_name(kb_name)
                ok, msg = kb.check_embed_model()
                if not ok:
                    raise ValueError(msg)
                
                # 使用重写后的query检索(重要!)
                docs = await run_in_threadpool(search_docs,
                                                query=optimized_query,  # 改这里!
                                                knowledge_base_name=kb_name,
                                                top_k=top_k,
                                                score_threshold=score_threshold,
                                                file_name="",
                                                metadata={})
                # ... 后续代码保持不变 ...
```

**完整修改示例**:

```python
async def kb_chat(query: str = Body(..., description="用户输入", examples=["你好"]),
                mode: Literal["local_kb", "temp_kb", "search_engine"] = Body("local_kb"),
                # ... 其他参数 ...
                ):
    if mode == "local_kb":
        kb = KBServiceFactory.get_service_by_name(kb_name)
        if kb is None:
            return BaseResponse(code=404, msg=f"未找到知识库 {kb_name}")
    
    async def knowledge_base_chat_iterator() -> AsyncIterable[str]:
        try:
            nonlocal history, prompt_name, max_tokens
            
            # ========== DeepRetrieval查询重写 ==========
            rewriter = get_query_rewriter()
            rewrite_result = rewriter.rewrite(query)
            
            original_query = query
            optimized_query = rewrite_result['rewritten']
            
            logger.info(
                f"🔄 [Query重写] {rewrite_result['method']} "
                f"({rewrite_result['latency_ms']:.0f}ms): "
                f"'{original_query}' -> '{optimized_query}'"
            )
            # ==========================================
            
            history = [History.from_data(h) for h in history]
            
            if mode == "local_kb":
                kb = KBServiceFactory.get_service_by_name(kb_name)
                ok, msg = kb.check_embed_model()
                if not ok:
                    raise ValueError(msg)
                
                # 使用重写后的query
                docs = await run_in_threadpool(
                    search_docs,
                    query=optimized_query,  # ← 使用重写后的query
                    knowledge_base_name=kb_name,
                    top_k=top_k,
                    score_threshold=score_threshold,
                    file_name="",
                    metadata={}
                )
                
                source_documents = format_reference(kb_name, docs, api_address(is_public=True))
            
            # ... 后续代码完全不变 ...
```

✅ **检查点**: kb_chat.py修改完成,导入和重写逻辑都已添加

---

## ✅ 第五步: 测试和上线 (15分钟)

### 5.1 重启LangChain-Chatchat

```bash
# 如果使用screen
screen -ls  # 查看现有session
screen -X -S chatchat quit  # 关闭旧session

# 启动新session
screen -S chatchat
cd Langchain-Chatchat-master/libs/chatchat-server
python -m chatchat.startup

# Ctrl+A+D 退出screen
```

### 5.2 测试集成效果

创建测试脚本 `test_integration.py`:

```python
"""
集成测试脚本
"""

import requests
import json


def test_kb_chat(query: str, kb_name: str = "samples"):
    """测试知识库对话"""
    
    url = "http://localhost:7861/chat/kb_chat"
    
    payload = {
        "query": query,
        "kb_name": kb_name,
        "mode": "local_kb",
        "top_k": 5,
        "score_threshold": 0.5,
        "stream": False
    }
    
    print(f"\n{'='*60}")
    print(f"📝 测试Query: {query}")
    print(f"{'='*60}")
    
    response = requests.post(url, json=payload)
    
    if response.status_code == 200:
        result = response.json()
        print(f"✅ 状态: 成功")
        print(f"📄 回答: {result.get('answer', 'N/A')[:200]}...")
        print(f"📚 参考文档数: {len(result.get('docs', []))}")
    else:
        print(f"❌ 状态: 失败 ({response.status_code})")
        print(f"错误: {response.text}")
    
    return response


if __name__ == "__main__":
    # 测试用例(根据你的知识库调整)
    test_cases = [
        "胶原蛋白怎么吃",
        "孕妇能喝吗",
        "有什么效果",
        "和虾青素有什么区别"
    ]
    
    for query in test_cases:
        test_kb_chat(query, kb_name="wuboshi_faq")  # 改成你的知识库名
    
    print(f"\n{'='*60}")
    print("✅ 所有测试完成!")
    print("请检查LangChain-Chatchat日志,查看'🔄 Query重写'字样")
    print(f"{'='*60}")
```

运行测试:

```bash
python test_integration.py
```

### 5.3 查看日志确认

```bash
# 查看LangChain-Chatchat日志
tail -f Langchain-Chatchat-master/libs/chatchat-server/data/logs/*.log

# 应该能看到类似输出:
# 🔄 [Query重写] model (145ms): '胶原蛋白怎么吃' -> '胶原蛋白肽 使用方法 推荐用量'
```

### 5.4 对比测试

```python
# 创建 compare_results.py
import requests


def compare_with_without_rewrite(query: str):
    """对比有无查询重写的效果"""
    
    url = "http://localhost:7861/chat/kb_chat"
    payload = {
        "query": query,
        "kb_name": "wuboshi_faq",
        "top_k": 3,
        "stream": False
    }
    
    # 测试1: 启用查询重写
    # (在配置中enable: true)
    response1 = requests.post(url, json=payload)
    result1 = response1.json()
    
    print(f"Query: {query}")
    print(f"\n启用查询重写:")
    print(f"  回答: {result1.get('answer', '')[:150]}...")
    print(f"  相关度: {[doc.get('score', 0) for doc in result1.get('docs', [])[:3]]}")
    
    # TODO: 对比测试需要手动关闭enable后再测试


if __name__ == "__main__":
    compare_with_without_rewrite("胶原蛋白怎么吃")
```

✅ **检查点**: 测试通过,能看到查询重写日志

---

## 📊 验收标准

### 必须通过的检查项

- [ ] DeepRetrieval vLLM服务正常运行
- [ ] LangChain-Chatchat服务正常运行
- [ ] 测试查询能成功返回结果
- [ ] 日志中能看到"🔄 Query重写"字样
- [ ] 查询重写latency < 500ms
- [ ] 系统整体响应正常

### 效果评估指标

运行一周后,收集以下数据:

| 指标 | 目标 | 实际 | 达成 |
|------|------|------|------|
| 查询重写成功率 | > 95% | ___ % | ☐ |
| 平均重写延迟 | < 300ms | ___ ms | ☐ |
| 用户满意度提升 | > 10% | ___ % | ☐ |
| 系统可用性 | > 99% | ___ % | ☐ |

---

## 🔧 常见问题排查

### 问题1: 日志中没有看到查询重写

**症状**: 测试时没有"🔄 Query重写"日志

**排查步骤**:
```bash
# 1. 检查配置
cat data/query_rewrite_settings.yaml
# 确认 enable: true

# 2. 检查导入
cd chatchat/server/chat
grep "query_rewriter" kb_chat.py
# 应该有import语句

# 3. 检查日志级别
# 在startup.py中设置
import logging
logging.basicConfig(level=logging.INFO)
```

### 问题2: 查询重写失败,使用rule降级

**症状**: 日志显示 `[Query重写] rule`

**原因**: vLLM服务不可达或超时

**排查步骤**:
```bash
# 1. 检查vLLM服务
curl http://localhost:8001/v1/models

# 2. 检查端口
netstat -tlnp | grep 8001

# 3. 检查防火墙
# Windows
netsh advfirewall firewall show rule name=all | findstr 8001

# 4. 测试连接
python -c "
from openai import OpenAI
client = OpenAI(api_key='EMPTY', base_url='http://localhost:8001/v1')
print(client.models.list())
"
```

### 问题3: 查询重写很慢(>1s)

**症状**: latency_ms > 1000

**优化方案**:
```yaml
# 调整配置
query_rewrite_settings:
  timeout: 1.0  # 降低超时时间,快速降级
  
  cache:
    enabled: true  # 启用缓存
    max_size: 5000
```

```python
# 在query_rewriter.py中添加缓存
from functools import lru_cache

class QueryRewriterMiddleware:
    def __init__(self, ...):
        # ...
        self.cache = {}
    
    def rewrite(self, query, context=""):
        # 检查缓存
        cache_key = f"{query}:{context}"
        if cache_key in self.cache:
            result = self.cache[cache_key]
            result['latency_ms'] = 0  # 缓存命中
            return result
        
        # 原有逻辑...
        result = self._do_rewrite(query, context)
        
        # 存入缓存
        if len(self.cache) < 1000:
            self.cache[cache_key] = result
        
        return result
```

### 问题4: ImportError或ModuleNotFoundError

**症状**: `ImportError: cannot import name 'get_query_rewriter'`

**解决方案**:
```bash
# 1. 检查文件是否存在
ls chatchat/server/middleware/query_rewriter.py

# 2. 检查__init__.py
cat chatchat/server/middleware/__init__.py

# 3. 重启Python环境
# 如果使用conda/venv,重新激活

# 4. 检查Python路径
python -c "import sys; print(sys.path)"
```

---

## 🎯 下一步优化建议

集成成功后,可以进一步优化:

### Week 2: 性能优化
- [ ] 启用缓存机制
- [ ] 批量查询重写
- [ ] 异步处理优化

### Week 3: 效果优化
- [ ] 收集badcase
- [ ] 优化规则库
- [ ] 调整模型prompt

### Week 4: 混合检索
- [ ] 实现RRF融合
- [ ] 添加重排序
- [ ] A/B测试对比

---

## 📚 相关文档

- [细化集成方案全文](./DeepRetrieval_LangChain_细化集成方案.md)
- [方案对比说明](./方案对比与改进说明.md)
- [DeepRetrieval训练指南](./QUICKSTART_zh.md)
- [LangChain-Chatchat官方文档](https://github.com/chatchat-space/Langchain-Chatchat)

---

## ✅ 完成确认

恭喜!如果你完成了所有5个步骤,现在你已经:

- ✅ 成功将DeepRetrieval集成到LangChain-Chatchat
- ✅ 实现了查询重写能力
- ✅ 具备完整的降级机制
- ✅ 系统稳定运行

**下一步行动**:
1. 收集一周的使用数据
2. 分析查询重写效果
3. 根据badcase优化规则
4. 考虑实施混合检索策略

有任何问题,请查看"常见问题排查"部分或查阅详细文档!

🎉 **Happy Coding!**

